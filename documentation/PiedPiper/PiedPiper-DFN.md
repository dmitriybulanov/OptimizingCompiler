## Построение глубинного остовного дерева

### Выполнено командой:
*PiedPiper (Бергер Анна, Колесников Сергей)*

### От каких проектов зависит:
1. Граф управления потока

### Зависимые проекты:
1. Нахождение естественных циклов

### Теория
Остовное дерево графа состоит из минимального подмножества рёбер графа, 
таких, что из любой вершины графа можно попасть в любую другую вершину, двигаясь по этим рёбрам.
Остовное дерево может быть построено практически любым алгоритмом обхода графа, например поиском 
в глубину или поиском в ширину. Оно состоит из всех пар рёбер ```(u,v)```, таких, 
что алгоритм, просматривая вершину ```u```, обнаруживает в её списке смежности новую, 
не обнаруженную ранее вершину ```v```. 

Поиск в графе в глубину (depth-first search) однократно посещает все узлы графа, начиная с входного узла и посещая, в первую 
очередь, насколько это возможно, узлы, максимально удаленные от входного. Путь поиска в глубину образует глубинное остовное дерево (охватывающее вглубь дерево) (depth-first spanning tree — DFST). Обход в прямом прядке посещает узел перед посещением любого из его дочерних узлов, которые затем рекурсивно посещаются в порядке слева направо. Обход в обратном порядке сначала рекурсивно слева направо посещает узлы, дочерние по отношению к текущему, а затем посещает сам текущий узел. 

### Входные данные:
 - Не требуются, остовное дерево строится в процессе построения CFG

### Выходные данные:
 - Ассоциативный массив <int, int>

### Реализация алгоритма
Узлы графа потока управления обходятся в прямом порядке и в процессе обхода нумеруются.
```cs
private void dfs(BasicBlock block, Dictionary<BasicBlock, bool> visited, ref int c)
{
  visited[block] = true;
  foreach (var node in getChildren(block.BlockId).Blocks)
  {
    if (!visited[node])
    {
      spanTree.AddEdge(new Edge<BasicBlock>(block, node));
      dfs(node, visited, ref c);
    }
  }
  spanTreeOrder[block.BlockId] = c;
  c--;
}
```
#### Пример использования
```cs
var b = BasicBlocksGenerator.CreateBasicBlocks(threeAddressCode);
Graph g = new Graph(b);
Dictionary<int, int> dfn = g.GetDFN();
```

### Тест
Программа:

```cs
b = 1;
if 1 
  b = 3;
else
  b = 2;
```

Управляющий граф программы
```
0:
<-- 
-->  1 2
1:
<--  0
-->  3
2:
<--  0
-->  3
3:
<--  1 2
--> 
```

Новое нумерование
```
3-->4
1-->3
2-->2
0-->1
```
