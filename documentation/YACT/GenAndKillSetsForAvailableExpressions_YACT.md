# Название задачи: вычисление `e_gen(b)` и `e_kill(b)` для доступных выражений

### Выполнено командой: YACT

### Постановка задачи: 

Необходимо по данному графу потока данных найти множества `e_gen` и `e_kill` для каждого базового блока. Эти данные используются алгоритмом анализа доступных выражений. 

### От каких проектов зависит:

  - CFG
  - Базовые блоки
  - Обобщенный итеративный алгоритм
  - Трехадресный код

### Зависимые проекты:

  - Анализатор доступных выражений

### Теория

**Доступные выражения** -- алгоритм анализа, определяющий для каждой точки в программе множество выражений, которые не требуется перевычислять. Такие выражения называются *доступными* в данной точке. Для того, чтобы быть доступными в точке программы, операнды выражения не должны быть изменены на любом пути от вхождения этого выражения до точки программы.

![alt text](https://github.com/wisestump/OptimizingCompiler/raw/master/documentation/YACT/img/GenKillExample.png "Gen-Kill Example")

### Входные данные:
 - Базовый блок

### Выходные данные:
 - Множество выражений

### Используемые структуры данных

 - `HashSet<Expression>` -- множество выражений

### Реализация алгоритма

```
// Метод получения множества Gen
public override ISet<Expression> GetGen(BasicBlock block)
{
    return SetFactory.GetSet( 
        block.Commands
            .OfType<Assignment>() // оставляем только присваивания 
            .Select(x => x.Value)); // из них берем правые части
}

// Метод получения множества Kill
public override ISet<Expression> GetKill(BasicBlock block)
{
    return SetFactory.GetSet(
        block.Commands
            .OfType<Assignment>() // оставляем только присваивания 
            .Select(x => x.Target as Expression)); // из них берем левые части
}
```

### Пример использования

/*результат работы*/

### Тест

/*небольшой тест на входных данных.*/