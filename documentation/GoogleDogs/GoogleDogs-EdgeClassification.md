# Классификация рёбер графа

### Выполнено командой: 
*Google Dogs (Александр Василенко, Кирилл Куц)*

### От каких проектов зависит:
1. Построение CFG
2. Построение дерева доминаторов
3. Построение глубинного остовного дерева

### Зависимые проекты:
1. Установить, все ли отступающие ребра являются обратными
2. Формирование последовательности областей в восходящем порядке

### Постановка задачи:
Необходимо классифицировать ребра графа потока управления на три вида:

1. *Наступающие* (advancing) ребра идут от узла *m* к истинным преемникам *m* в дереве.
2. *Отступающие* (retreating) ребра идут от узла *m* к предку *m* в дереве (возможно, к самому *m*).
3. *Поперечные* (cross) - все остальные ребра.

Пример:

![](img/ExampleEC.png?raw=true)

Рёбра 1 <html>&rarr;</html> 3, 6 <html>&rarr;</html> 7, 9 <html>&rarr;</html> 10 являются наступающими, рёбра 4 <html>&rarr;</html> 3, 7 <html>&rarr;</html> 4, 8 <html>&rarr;</html> 3 являются отступающими, рёбра 2 <html>&rarr;</html> 3, 5 <html>&rarr;</html> 7 - поперечными.

### Теория

Все ребра, попадающие в глубинное остовное дерево, являются *наступающими*. В примере выше такие ребра отмечаются сплошной стрелкой. Однако, если бы на графе потока управления существовало ребро, например, 1 <html>&rarr;</html> 4, оно бы тоже считалось *наступающим*, несмотря на то, что не входило бы в DFST.

Ребро *m <html>&rarr;</html> n* является *отступающим* тогда и только тогда, когда *dfn*[*m*] <html>&ge;</html> *dfn*[*n*]. Если *m* является потомком *n* в глубинном остовном дереве, то *search*(*m*) завершается до *search*(*n*), поэтому *dfn*[*m*] <html>&ge;</html> *dfn*[*n*]. И наоборот, если *dfn*[*m*] <html>&ge;</html> *dfn*[*n*], то *search(*m*) завершается до *search*(*n*), или *m* = *n*. Но вызов *search*(*n*) должен начинаться до *search*(*m*), если существует ребро *m <html>&rarr;</html> n*, иначе тот факт, что *n* является преемником *m*, должен сделать *n* потомком *m* в DFST. Таким образом, время активности *search*(*m*) 
представляет собой подынтервал времени активности *search*(*т*), откуда следует, что *n* является предком *т* в DFST.

Важным свойством *поперечных* ребер является то, что если изобразить DFST так, чтобы дочерние узлы некоторого узла располагались слева направо в порядке, в котором они добавлялись в дерево, то все *поперечные* ребра будут идти справа налево. В нашем языке *поперечные* ребра могут быть получены только в случае, если на графе потока управления можно найти так называемый "ромб": то есть из одного базового блока можно попасть в другой (не непосредственный потомок первого) по двум и более путям.

### Входные данные
- Граф потока управления

### Выходные данные
- Пары "ребро - тип ребра"

### Используемые структуры данных
- `Dictionary<Edge<BasicBlock>, EdgeType> edgeTypes` - хранение результата
- `Dictionary<int, int> dfn` - порядок узлов
- `DominatorsTree tree` - дерево доминаторов

### Реализация алгоритма
```cs
public static Dictionary<Edge<BasicBlock>, EdgeType>
    ClassifyEdge(ControlFlowGraph.Graph g)
{
    // Инициализация пустым словарем
    Dictionary<Edge<BasicBlock>, EdgeType> edgeTypes 
    = new Dictionary<Edge<BasicBlock>, EdgeType>();
    // Получение порядка узлов
    Dictionary<int, int> dfn = g.GetDFN();
    // Получение дерева доминаторов
    DominatorsTree tree = new DominatorsTree(g); 
    
    // Выполнение для всех ребер графа
    foreach (Edge<BasicBlock> e in g.GetEdges())
    {
        /* Если порядок начала больше порядка конца,
           то ребро отступающее*/
        if (dfn[e.Source.BlockId] >= dfn[e.Target.BlockId])
            edgeTypes.Add(e, EdgeType.Retreating);
        // Если предок в дереве, то наступающее
        else if (g.IsAncestor(e.Target.BlockId, e.Source.BlockId) 
        && tree.GetParent(e.Target.BlockId) == e.Source.BlockId)
            edgeTypes.Add(e, EdgeType.Advancing);
        // Иначе поперечное
        else
            edgeTypes.Add(e, EdgeType.Cross);
    }

    return edgeTypes;
}
```

### Пример использования
```cs
var edgeClassify = EdgeClassification.ClassifyEdge(g);
foreach (var v in edgeClassify)
    // В консоль выводятся вход и выход обратного ребра, а также тип ребра
    Console.WriteLine(v.Key.Source.BlockId + " -> "
    + v.Key.Target.BlockId + " : " + v.Value);
```

### Тест
*Программа*:
```
b = 1;
if 1 
  b = 3;
else
  b = 2;
```

*Граф потока управления*:

![](img/TestEC.png?raw=true)

Ребра *0 <html>&rarr;</html> 1* и *0 <html>&rarr;</html> 2* являются наступающими, а ребра *1 <html>&rarr;</html> 3* и *2 <html>&rarr;</html> 3* являются поперечными.

*Вывод программы*:

Формат вывода: "выход обратного ребра - вход обратного ребра - тип ребра"

0 -> 1 : Advancing                                                        
0 -> 2 : Advancing                                                              
1 -> 3 : Cross                                                                     
2 -> 3 : Cross